#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>

#include <linux/cdev.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/types.h>
#include <linux/timekeeping.h>

/*  dedup.c - The simplest kernel module.
 */

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("Insu Jang, Seikown Kim, and Seonyoung Lee");
MODULE_DESCRIPTION
    ("dedup - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "dedup"

struct dedup_local {
    int irq;
    unsigned long mem_start;
    unsigned long mem_end;
    void __iomem *base_addr;
};

static struct timespec t_start, t_end;
static unsigned int iteration;
static long long accumulatedComputingTime;
static struct dedup_local *lp = NULL;

static irqreturn_t dedup_irq(int irq, void *lp)
{
	// printk("dedup interrupt\n");

    // Clear the interrupt by writing and value to the interrupt status register (ISR).
    iowrite32(1, ((struct dedup_local *)lp)->base_addr + 0xc);
    
    return IRQ_HANDLED;
}

static int dedup_probe(struct platform_device *pdev)
{
	struct resource *r_irq; /* Interrupt resources */
	struct resource *r_mem; /* IO mem resources */
	struct device *dev = &pdev->dev;
	
    int rc = 0;
	
	dev_info(dev, "Device Tree Probing\n");

	/* Get iospace for the device */
	r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!r_mem) {
		dev_err(dev, "invalid address\n");
		return -ENODEV;
	}
	
	lp = (struct dedup_local *) kmalloc(sizeof(struct dedup_local), GFP_KERNEL);
	if (!lp) {
		dev_err(dev, "Cound not allocate dedup device\n");
		return -ENOMEM;
	}
	
	dev_set_drvdata(dev, lp);
	
	lp->mem_start = r_mem->start;
	lp->mem_end = r_mem->end;

	if (!request_mem_region(lp->mem_start,
				lp->mem_end - lp->mem_start + 1,
				DRIVER_NAME)) {
		dev_err(dev, "Couldn't lock memory region at %p\n",
			(void *)lp->mem_start);
		rc = -EBUSY;
		goto error1;
	}

	lp->base_addr = ioremap(lp->mem_start, lp->mem_end - lp->mem_start + 1);
	if (!lp->base_addr) {
		dev_err(dev, "dedup: Could not allocate iomem\n");
		rc = -EIO;
		goto error2;
	}

	/* Get IRQ for the device */
	r_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
	if (!r_irq) {
		dev_info(dev, "no IRQ found\n");
		dev_info(dev, "dedup at 0x%08x mapped to 0x%08x\n",
			(unsigned int __force)lp->mem_start,
			(unsigned int __force)lp->base_addr);
		return 0;
	}
	lp->irq = r_irq->start;
	
	rc = request_irq(lp->irq, &dedup_irq, 0, DRIVER_NAME, lp);
	if (rc) {
		dev_err(dev, "testmodule: Could not allocate interrupt %d.\n",
			lp->irq);
		goto error3;
	}

	dev_info(dev,"dedup at 0x%08x mapped to 0x%08x, irq=%d\n",
		(unsigned int __force)lp->mem_start,
		(unsigned int __force)lp->base_addr,
		lp->irq);
	return 0;
error3:
	free_irq(lp->irq, lp);
error2:
	release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
error1:
	kfree(lp);
	dev_set_drvdata(dev, NULL);
	return rc;
}

static int dedup_remove(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct dedup_local *lp = dev_get_drvdata(dev);
	free_irq(lp->irq, lp);
	release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
	kfree(lp);
	dev_set_drvdata(dev, NULL);
	return 0;
}

#ifdef CONFIG_OF
static struct of_device_id dedup_of_match[] = {
	{ .compatible = "xlnx,dedup-1.0", },
	{ /* end of list */ },
};
MODULE_DEVICE_TABLE(of, dedup_of_match);
#else
# define dedup_of_match
#endif


static struct platform_driver dedup_driver = {
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table	= dedup_of_match,
	},
	.probe		= dedup_probe,
	.remove		= dedup_remove,
};


static int chrdev_initialize(void);
static int __init dedup_init(void)
{
	printk("Dedup device driver initializing.\n");
    chrdev_initialize();
	return platform_driver_register(&dedup_driver);
}


static void chrdev_destroy(void);
static void __exit dedup_exit(void)
{
    chrdev_destroy();
	platform_driver_unregister(&dedup_driver);
	printk(KERN_ALERT "Dedup device driver is detached.\n");
}

module_init(dedup_init);
module_exit(dedup_exit);

// ----------------------------------------------------
// character device driver functionality
// ----------------------------------------------------

static int dedup_chrdev_open(struct inode *inode, struct file *file){
    u32 reg;

    printk(KERN_INFO "device open(%p,%p)\n", inode, file);

    // Disable auto restart
    iowrite32(0, lp->base_addr);

    // Enable global interrupt
    iowrite32(1, lp->base_addr + 0x4);

    // Enable interrupt source for ap_done
    reg = ioread32(lp->base_addr + 0x8);
    iowrite32(reg | 1, lp->base_addr + 0x8);

    try_module_get(THIS_MODULE);
    
    iteration = 0;
    accumulatedComputingTime = 0;

    return 0;
}

static int dedup_chrdev_release(struct inode *inode, struct file *file){
    printk(KERN_INFO "device release(%p,%p)\n", inode, file);
    module_put(THIS_MODULE);

    return 0;
}

static ssize_t dedup_invoke(struct file *file, const char __user *buffer,
                            size_t length, loff_t *offset){
    u32 reg;
    
    // printk(KERN_INFO "Invoking Deduplication PL.\n");
    reg = ioread32(lp->base_addr);
    //printk("ap_start: %d\n", reg & 1);
    //printk("ap_done: %d\n", (reg >> 1) && 1);
    //printk("ap_idle: %d\n", (reg >> 2) && 1);
    //printk("ap_ready: %d\n", !(reg & 1));

    // Initiate PL execution
    iowrite32(reg | 1, lp->base_addr);
    return 0;
}


static struct file_operations fops = {
    .owner = THIS_MODULE,
    .write = dedup_invoke,
    .open = dedup_chrdev_open,
    .release = dedup_chrdev_release,
};


static dev_t dev;
static struct class *cdev_class = NULL;
static struct cdev cdev;

#define DEVICE_NAME "dedup"

static int chrdev_initialize(void){
    int rc;

    // Get a range of minor numbers to work with
    // Minor numbers start at 0
    rc = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);
    if(rc < 0){
        printk(KERN_ERR "Unable to allocate character device region.\n");
        return rc;
    }

    // Create a device class
    cdev_class = class_create(THIS_MODULE, DEVICE_NAME);
    if(IS_ERR(DEVICE_NAME)){
        rc = -1;
        printk(KERN_ERR "Unable to create a device class.\n");
        goto unregister;
    }

    // Create a device for our module. This will create a file on /dev/dedup
    if(device_create(cdev_class, NULL, dev, NULL, DEVICE_NAME) == NULL){
        rc = -1;
        printk(KERN_ERR "Unable to add a character device.\n");
        goto unregister;
    }

    // Register our character device to the kernel
    cdev_init(&cdev, &fops);
    rc = cdev_add(&cdev, dev, 1);
    if(rc < 0){
        printk(KERN_ERR "Unable to add a character device.\n");
        goto destroy;
    }

    printk(KERN_INFO "Successfully created a character device.\n");

    return 0;

destroy:
    device_destroy(cdev_class, dev);
    class_destroy(cdev_class);
unregister:
    unregister_chrdev_region(dev, 1);

    return rc;
}

static void chrdev_destroy(void){
    cdev_del(&cdev);
    device_destroy(cdev_class, dev);
    class_destroy(cdev_class);
    unregister_chrdev_region(dev, 1);
    printk(KERN_INFO "Successfully destroyed a character device.\n");
}
